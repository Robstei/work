#########EYE TRACKER##################
	
	string iViewX_IP = "192.168.1.2";
	string Local_IP = "192.168.1.1";
	int Send_Port = 4444;
	int Recv_Port = 5555;

	#create iViewXAPI::eye_tracker2 instance 
	iViewXAPI::eye_tracker2 tracker2;

	# create eye_tracker instance 
	eye_tracker tracker;

	#create extension objects
	tracker2 = new iViewXAPI::eye_tracker2( "{B7A4A7F7-7879-4C95-A3BA-6CCB355AECF6}" );
	tracker2.disconnect();
	tracker2.connect(iViewX_IP, Send_Port, Local_IP, Recv_Port);

	tracker = new eye_tracker( "{FDC35980-7480-4761-859F-4DCCFA93BA57}" );

	tracker.clear_buffer(dt_position);
	tracker.start_tracking();
	tracker.start_data(dt_position);
	
	
double accuracy_x, accuracy_y;
	
##### calibration

######### calibration ##########

# Calibration method 
#double calibration_method = 1.0;
#double calibration_method = 2.0;
double calibration_method = 5.0;
#double calibration_method = 9.0;
#double calibration_method = 13.0;

# Calibration auto accept
#double calibration_auto_accept = 0.0;
double calibration_auto_accept = 1.0;
#double calibration_auto_accept = 2.0;

# Calibration speed
#double calibration_speed = 0.0;
double calibration_speed = 1.0;

term.print ( "calibration" ); term.print ( "\n" );
tracker.calibrate(et_calibrate_default, calibration_method, calibration_auto_accept, calibration_speed);
wait_interval (500);

##### validation 
		
term.print ( "validation" ); term.print ( "\n" );	
tracker.calibrate(2, calibration_method, calibration_auto_accept, calibration_speed);

accuracy_x = tracker2.get_accuracy_x();
accuracy_y = tracker2.get_accuracy_y();
		
term.print ( "x\t" ); term.print ( string(accuracy_x) ); term.print ( "\t" );
term.print ( "y\t" ); term.print ( string(accuracy_y) ); term.print ( "\n" );

wait_interval (500);
tracker.set_recording(true);

	sub print_et_status(string code)
	begin
		term.print_line("\n-------------" + code +"------------");
		int status = tracker.get_status();
		term.print("Status: ");
		if (status == tracker.STATUS_STOPPED)
		then
			term.print_line("stopped");
		elseif(status == tracker.STATUS_INITIALIZING)
		then
			term.print_line("initializing");
		elseif(status == tracker.STATUS_TRACKING)
		then
			term.print_line("tracking");
		elseif(status == tracker.STATUS_ERROR)
		then
			term.print_line("error");
		end;
		
		term.print_line("\n-------------" + code +"------------");
	end;
	
	########END EYE TRACKER############

	int COLOR = 1;
	int FORM = 2;
	array <int> ISI_values [] = {500, 700, 900, 1100, 1300, 1500, 1700, 1900, 2100, 2300};
	array <int> array_color_indexes [] = {1,2,3,4,5,6};
	
	
	array <string> array_instructions [][] = {
		{ 
			"Drücke die Taste \"L\" wenn",
			"erscheint.",
			"Drücke die Taste \"S\" wenn",
			"erscheint.",
			"Antworte so schnell und richtig wie möglich.",
			"Drücke die Leertaste um weiter zu kommen."
		},
		{
			"Press the key \"L\" if",
			"appears.",
			"Press the key \"S\" if",
			"appears.",
			"React as fast and as correct as possible.",
			"Press space bar to continue."
		}
	};
	
	array<string> array_feedback [2][4]; 
	array_feedback[1][1] = parameter_manager.get_string("Feedback HIT GER", "Richtig.");
	array_feedback[1][2] = parameter_manager.get_string("Feedback INCORRECT GER", "Falsche Taste.");
	array_feedback[1][3] = parameter_manager.get_string("Feedback MISS GER", "Falsch.\nDu hättest drücken müssen.");
	array_feedback[1][4] = parameter_manager.get_string("Feedback FALSE ALARM GER", "Falsch.\nDu hättest nicht drücken müssen.");
		
	array_feedback[2][1] = parameter_manager.get_string("Feedback HIT ENG", "Right.");
	array_feedback[2][2] = parameter_manager.get_string("Feedback INCORRECT ENG", "Wrong key.");
	array_feedback[2][3] = parameter_manager.get_string("Feedback MISS ENG", "You should have reacted.");
	array_feedback[2][4] = parameter_manager.get_string("Feedback FALSE ALARM ENG", "You should not have reacted.");
	
	array<string> array_information[2][6];
	array_information[1][1] =
		"Im Folgenden werden dir auf dem Bildschirm unterschiedliche Farben und Formen präsentiert. " +
		"Vor jedem Durchlauf erhältst du eine kurze Instruktion, auf welche Farben und/oder Formen du reagieren sollst. " + 
		"Die Reaktion erfolgt mit den Tasten \"L\" und \"S\". Reagiere so schnell und so richtig wie möglich.\n\n" +
		"Zunächst folgt ein Testdurchlauf.\n\n" +
		"Drücke die Leertaste, um fortzufahren.";
	array_information[1][2] = 
		"Dies ist ein Testdurchlauf. \n\n Weiter mit Leertaste.";
	array_information[1][3] =
		"Der Testdurchlauf ist vorbei.\n\n" +
		"Im Folgenden wird dir kein Feedback mehr präsentiert.\n\n" +
		"Der erste Durchgang beginnt.\n" + 
		"Weiter mit Leertaste.";
	array_information[1][4] =
		"Der zweite Durchgang beginnt.\n" + 
		"Weiter mit Leertaste.";
	array_information[1][5] =
		"Der dritte Durchgang beginnt.\n" + 
		"Weiter mit Leertaste.";
	array_information[1][6] =
		"Bitte wende dich sich an den Versuchsleiter.";
		
	array_information[2][1] = 
		"In the following, you will see different numbers and shapes on the screen. Before each run, you will receive a brief instruction on " +
		"which numbers and/or shapes you should react to. Please use the keys \"L\" and \"S\". React as fast and as correct as possible." +
		"\n\nFirst, a test run follows.\n\nPress space bar to continue.";
	array_information[2][2] = "This is a test run.\n\nSpace bar to continue.";
	array_information[2][3] = "Test run is over.\n\n In the following, no feedback will be given.\n\n" + "The first run begins.\n Space bar to continue.";
	array_information[2][4] = "The second run begins.\n Space bar to continue.";
	array_information[2][5] = "The third run begins.\n Space bar to continue.";
	array_information[2][6] = "Please contact the experimenter.";
	
	int configuration = parameter_manager.get_int("Configuration Parameter");
	int non_targets = parameter_manager.get_int("Non Targets at Start of each Block");
	int language = parameter_manager.get_int("Language");
	
	sub pause_seconds (int time_in_seconds)
	begin
		tracker.send_message("Pause.jpg");
		loop int start_time = clock.time()
		until clock.time() > start_time + time_in_seconds * 1000
		begin
			if language == 1
			then
				pause_text.set_caption("Pause \nIn " + string(time_in_seconds - floor((clock.time() - start_time) / 1000)) + " Sekunden geht es weiter", true);
				trial_pause.present();
			elseif language == 2
			then
				pause_text.set_caption("Break \nIt continues in " + string(time_in_seconds - floor((clock.time() - start_time) / 1000)) + " seconds", true);
				trial_pause.present();
			end;
		end;
     end;
	
	sub pause_minutes (int time_in_minutes)
	begin
		tracker.send_message("Pause.jpg");
		int time_in_seconds = time_in_minutes * 60;
		loop int start_time = clock.time()
		until clock.time() > start_time + time_in_seconds * 1000
		begin
			if language == 1
			then
				pause_text.set_caption("Pause \nIn " + string(time_in_seconds - floor((clock.time() - start_time) / 1000)) + " Sekunden geht es weiter", true);
				trial_pause.present();
			elseif language == 2
			then
				pause_text.set_caption("Break \nIt continues in " + string(time_in_seconds - floor((clock.time() - start_time) / 1000)) + " seconds", true);
				trial_pause.present();
			end;
		end;
	end;
	
	sub set_logfile_name
	begin
			logfile.set_filename(logfile.subject() + "_" + "swad_kids_" + date_time("mm_dd_yyyy") + ".log");
	end;
	
	sub present_information (string information, int font_size)
	begin
		text_introduction.set_font_size(font_size);
		text_introduction.set_caption(information, true);
		tracker.send_message("Information.jpg");
		trial_information.present();
	end;
		
	sub set_response_mode (int mode)
	begin
		if mode == 1
		then
			response_manager.set_button_active(1, false);
			response_manager.set_button_active(2, false);
			response_manager.set_button_active(3, true);
		elseif mode == 2
		then
			response_manager.set_button_active(1, true);
			response_manager.set_button_active(2, true);
			response_manager.set_button_active(3, false);
		end;
	end;
	
	sub change_color(ellipse_graphic eg, int color_index)
	begin
		if color_index == 1
		then
			eg.set_color(255,0,0,255);
			eg.redraw();
		elseif color_index == 2
		then
			eg.set_color(0,0,0,255);
			eg.redraw();
		elseif color_index == 3
		then
			eg.set_color(255,204,0,255);
			eg.redraw();
		elseif color_index == 4
		then
			eg.set_color(0,102,255,255);
			eg.redraw();
		elseif color_index == 5
		then
			eg.set_color(0,204,0,255);
			eg.redraw();
		elseif color_index == 6
		then
			eg.set_color(153,0,153,255);
			eg.redraw();
		end;
	end;
	
	#creates 5 categories of stimuli and groups them for analysis regarding the eye tracker
	# 1. test stimuli
	# 2. Selective blocks
	# 3. Divided blocks
	# 4. Switching blocks with selective attention
	# 5. Switching blocks with divided attention
	
	sub send_eye_tracker_message (int seperate_attention, string run_id, bool is_target, string divided_attention_target)
	begin
		string message = run_id;
		
		if (run_id == "switching")
		then 
			if (seperate_attention == 1 || seperate_attention == 2)
			then
				message = message + "_selective";
			elseif (seperate_attention == 3)
			then
				message = message + "_divided";
			end;
		end;
		
		if (seperate_attention == 1)
		then
			message = message + "_color";
		elseif (seperate_attention == 2)
		then
			message = message + "_form";
		end;
		
		if (seperate_attention == 3 && divided_attention_target != "")
		then
			message = message + "_" + divided_attention_target;
		end;
		
		if (is_target)
		then
			message = message + "_target";
		else
			message = message + "_non_target";
		end;
		
		if(run_id == "test")
		then
			message = "test";
		end;
		
		message = message + ".jpg";
		tracker.send_message(message);
	end;
	
	# returns true if
	# 1. successive stimuli are never identical
	# 2. first "Non Targets at Start of each Block" (parameter) are non targets
	# 3. successive stimuli are never targets
	
	sub bool validade (array<int,2> list_to_test, int seperate_attention, int form_target_index, 
							int color_target_index, array<int,1> color_indexes)
	begin
		loop int i = 1 until i == list_to_test.count()
		begin
			if list_to_test[i] == list_to_test[i+1]
			then 
				return false;
			end;
			i = i + 1;
		end;
		
		loop int i = 1 until i > non_targets
		begin
			if seperate_attention == 1 
			then
				if color_indexes[list_to_test[i][COLOR]] == color_indexes[color_target_index]
				then
					return false;
				end;
			elseif seperate_attention == 2			
			then
				if list_to_test[i][FORM] == form_target_index
				then
					return false;
				end;
			elseif seperate_attention == 3 &&
				(color_indexes[list_to_test[i][COLOR]] == color_indexes[color_target_index]
				|| list_to_test[i][FORM] == form_target_index)
			then
				return false;
			end;
			i = i + 1;
		end;		
	
		loop int i = (non_targets + 1) until i == list_to_test.count()
		begin
			if seperate_attention == 1
			then
					if color_indexes[list_to_test[i][COLOR]] == color_indexes[color_target_index] &&
					color_indexes[list_to_test[i+1][COLOR]] == color_indexes[color_target_index]
				then 
					return false;
				end;
			elseif seperate_attention == 2
			then
				if list_to_test[i][FORM] == form_target_index &&
					list_to_test[i+1][FORM] == form_target_index 
				then
					return false;
				end;
			elseif seperate_attention == 3 &&
						(color_indexes[list_to_test[i][COLOR]] == color_indexes[color_target_index]
								|| list_to_test[i][FORM] == form_target_index)
			then
				if 
					color_indexes[list_to_test[i+1][COLOR]] == color_indexes[color_target_index]
								|| list_to_test[i+1][FORM] == form_target_index
				then
					return false;
				end;
			end;
			i = i +1;
		end;
		return true;
	end;

	# returns  a 2D array representation of a valid block with given paramters
	# for each pair the first value represents the index of the used char in color_indexes and the second value
	# represents the index of the used form in form_array
	# see make_and_present_block for parameter explanation
	
	sub array<int,2> make_block (int seperate_attention, int color_target_index, array<int,1> color_indexes,
											int form_target_index, int number_of_targets, int number_of_non_targets)
	begin
		array<int> list[0][2];
		array<int> tmp_possible_targets[0][2];
		array<int> tmp_possible_color_targets[0][2];
		array<int> tmp_possible_form_targets[0][2];
		array<int> tmp_possible_non_targets[0][2];
		
		if seperate_attention == 1
		then
			loop int i = 1 until i > form_array.count()
			begin
				array<int> tmp[2];
				tmp[COLOR] = color_target_index;
				tmp[FORM] = i;
				tmp_possible_targets.add(tmp);
				i = i + 1;
			end;
			tmp_possible_targets.shuffle();
			
			loop int i = 1 until i > number_of_targets
			begin
				int index = i % tmp_possible_targets.count();
				if index == 0
				then
					list.add(tmp_possible_targets[tmp_possible_targets.count()]);
				else
					list.add(tmp_possible_targets[index]);
				end;
				i = i + 1;
			end;
			
			loop int color_count = 1 until color_count > color_indexes.count()
			begin
				loop int form_count = 1 until form_count > form_array.count()
				begin
					if color_count != color_target_index
					then
						array<int> tmp[2];
						tmp[COLOR] = color_count;
						tmp[FORM] = form_count;
						tmp_possible_non_targets.add(tmp);
					end;
					form_count = form_count + 1;
				end;
				color_count = color_count + 1;
			end;
			tmp_possible_non_targets.shuffle();		
			
			
			loop int i = 1 until list.count() == number_of_targets + number_of_non_targets
			begin
				int index = i % tmp_possible_non_targets.count();
				if index == 0
				then
					list.add(tmp_possible_non_targets[tmp_possible_non_targets.count()]);
				else
					list.add(tmp_possible_non_targets[index]);
				end;
				i = i + 1;
			end;
			
		elseif seperate_attention == 2
		then
			loop int i = 1 until i > color_indexes.count()
			begin
				array<int> tmp[2];
				tmp[COLOR] = i;
				tmp[FORM] = form_target_index;
				tmp_possible_targets.add(tmp);
				i = i + 1;
			end;
			tmp_possible_targets.shuffle();
			
			loop int i = 1 until i > number_of_targets
			begin
				int index = i % tmp_possible_targets.count();
				if index == 0
				then
					list.add(tmp_possible_targets[tmp_possible_targets.count()]);
				else
					list.add(tmp_possible_targets[index]);
				end;
				i = i + 1;
			end;
			
			loop int color_count = 1 until color_count > color_indexes.count()
			begin
				loop int form_count = 1 until form_count > form_array.count()
				begin
					if form_count != form_target_index
					then
						array<int> tmp[2];
						tmp[COLOR] = color_count;
						tmp[FORM] = form_count;
						tmp_possible_non_targets.add(tmp);
					end;
					form_count = form_count + 1;
				end;
				color_count = color_count + 1;
			end;
			tmp_possible_non_targets.shuffle();		
			
			
			loop int i = 1 until list.count() == number_of_targets + number_of_non_targets
			begin
				int index = i % tmp_possible_non_targets.count();
				if index == 0
				then
					list.add(tmp_possible_non_targets[tmp_possible_non_targets.count()]);
				else
					list.add(tmp_possible_non_targets[index]);
				end;
				i = i + 1;
			end;
		elseif seperate_attention == 3
		then
			loop int i = 1 until i > form_array.count()
			begin
				if i != form_target_index
				then
					array<int> tmp[2];
					tmp[COLOR] = color_target_index;
					tmp[FORM] = i;
					tmp_possible_color_targets.add(tmp);
				end;
				i = i + 1;
			end;
			tmp_possible_color_targets.shuffle();
			
			loop int i = 1 until i > color_indexes.count()
			begin
				if i != color_target_index
				then
					array<int> tmp[2];
					tmp[COLOR] = i;
					tmp[FORM] = form_target_index;
					tmp_possible_form_targets.add(tmp);
				end;
				i = i + 1;
			end;
			tmp_possible_form_targets.shuffle();
			
			loop int i = 1 until i > number_of_targets/2
			begin
				int color_index = i % tmp_possible_color_targets.count();
				if color_index == 0
				then
					list.add(tmp_possible_color_targets[tmp_possible_color_targets.count()]);
				else
					list.add(tmp_possible_color_targets[color_index]);
				end;
				
				int form_index = i % tmp_possible_form_targets.count();
				if form_index == 0
				then
					list.add(tmp_possible_form_targets[tmp_possible_form_targets.count()]);
				else
					list.add(tmp_possible_form_targets[form_index]);
				end;
				i = i + 1;
			end;
			
			loop int color_count = 1 until color_count > color_indexes.count()
			begin
				loop int form_count = 1 until form_count > form_array.count()
				begin
					if color_count != color_target_index && form_count!= form_target_index
					then
						array<int> tmp[2];
						tmp[COLOR] = color_count;
						tmp[FORM] = form_count;
						tmp_possible_non_targets.add(tmp);
					end;
					form_count = form_count + 1;
				end;
				color_count = color_count + 1;
			end;
			tmp_possible_non_targets.shuffle();		
			
			loop int i = 1 until list.count() == number_of_targets + number_of_non_targets
			begin
				int index = i % tmp_possible_non_targets.count();
				if index == 0
				then
					list.add(tmp_possible_non_targets[tmp_possible_non_targets.count()]);
				else
					list.add(tmp_possible_non_targets[index]);
				end;
				i = i + 1;
			end;
		end;
		
		loop until (validade(list, seperate_attention ,form_target_index,
						color_target_index, color_indexes))
		begin
			list.shuffle();
		end;
		return list;
	end;

	# presents a block with given paramters.
	# that means showing instructions, fixation cross and possibly feedback.
	# The block is normally created by make_block() but could be created manually aswell
	# see make_and_present_block for parameter explanation
	
	sub present_block( int seperate_attention, int color_target_index, array<int,1> color_indexes, 
								int form_target_index, array<int> block[][], bool show_feedback, string run_id, string block_id)
	begin
		
		if seperate_attention == 1
		then
			text_instruction_color1.set_caption(array_instructions[language][1], true);
			
			change_color(ellipse_instruction, color_target_index);
			
			text_instruction_color2.set_caption(array_instructions[language][2], true);
			text_instruction_color5.set_caption(array_instructions[language][5], true);
			text_instruction_color6.set_caption(array_instructions[language][6], true);
			tracker.send_message("Instruction_color.jpg");
			trial_instruction_color.present();
		elseif seperate_attention == 2
		then
			text_instruction_form3.set_caption(array_instructions[language][3], true);
			
			bitmap_target_form.set_filename(bitmap(form_array[form_target_index].get_part(1)).filename());
			bitmap_target_form.load();
			
			text_instruction_form4.set_caption(array_instructions[language][4], true);
			text_instruction_form5.set_caption(array_instructions[language][5], true);
			text_instruction_form6.set_caption(array_instructions[language][6], true);
			tracker.send_message("Instruction_form.jpg");
			trial_instruction_form.present();
		elseif seperate_attention == 3
		then
			text_instruction_divided1.set_caption(array_instructions[language][1], true);
			
			bitmap_target_divided.set_filename(bitmap(form_array[form_target_index].get_part(1)).filename());
			bitmap_target_divided.load();
			
			text_instruction_divided2.set_caption(array_instructions[language][2], true);
			text_instruction_divided3.set_caption(array_instructions[language][3], true);
			
			change_color(ellipse_instruction, color_target_index);
			
			text_instruction_divided4.set_caption(array_instructions[language][4], true);
			text_instruction_divided5.set_caption(array_instructions[language][5], true);
			text_instruction_divided6.set_caption(array_instructions[language][6], true);
			tracker.send_message("Instruction_divided.jpg");
			trial_instruction_divided.present();
		end;
		
			
	
	
	
		loop int i = 1 until i > block.count()
		begin
			bool is_target = false;
			string divided_attention_target = "";
			int color_index = block[i][COLOR];
			int form_index = block[i][FORM];

			main_picture = form_array[form_index];
			change_color(ellipse_graphic(main_picture.get_part(2)), color_index);
			stim_event.set_stimulus(main_picture);
			string tmp_event_code = string(configuration) + ";" + run_id + ";" + block_id + ";" + main_picture.description() + 
												";" + string(color_index) + ";" + string(seperate_attention);

			stim_event.set_target_button(0);
			stim_event.set_response_active(true);
						
			if seperate_attention == 1
			then
				if color_target_index == color_index
				then
					stim_event.set_target_button(1);
					stim_event.set_event_code(tmp_event_code + ";" + "1");
					is_target = true;
				else
					stim_event.set_event_code(tmp_event_code + ";" + "0");
				end;
			elseif seperate_attention == 2
			then
				if form_target_index == form_index
				then 
					stim_event.set_target_button(2);
					stim_event.set_event_code(tmp_event_code + ";" + "2");
					is_target = true;
				else
					stim_event.set_event_code(tmp_event_code + ";" + "0");
				end;
			elseif seperate_attention == 3 
			then
				if color_target_index == color_index
				then
					stim_event.set_target_button(1);
					stim_event.set_event_code(tmp_event_code + ";" + "1");
					is_target = true;
					divided_attention_target = "color";
				elseif form_target_index == form_index
				then
					stim_event.set_target_button(2);
					stim_event.set_event_code(tmp_event_code + ";" + "2");
					is_target = true;
					divided_attention_target = "form";
				else
					stim_event.set_event_code(tmp_event_code + ";" + "0");
				end;
			else	
			end;
			
			#ISI
			if i == 1
			then 
				trial_cross.set_duration(1000);
			else
				trial_cross.set_duration(ISI_values[random(1,ISI_values.count())]);
			end;
			tracker.send_message("Fixation.jpg");
			trial_cross.present();
			
			set_response_mode(2);
			
			send_eye_tracker_message(seperate_attention, run_id, is_target, divided_attention_target);
			
			trial_main.present();
			set_response_mode(1);
			
			i=i+1;
		
			if show_feedback
			then
				string feedback = "";
				stimulus_data last = stimulus_manager.last_stimulus_data();
				if (last.type() == last.HIT)
				then
					feedback = array_feedback[language][1];
				elseif (last.type() == last.INCORRECT)
				then
					feedback = array_feedback[language][2];
				elseif (last.type() == last.MISS)
				then
					feedback = array_feedback[language][3];
				elseif (last.type() == last.FALSE_ALARM)
				then
					feedback = array_feedback[language][4];
				end;
				
				if feedback != ""
				then
				text_feedback.set_caption(feedback, true);
				tracker.send_message("Feedback.jpg");
				trial_feedback.present();	
				end;
			end;
		end;
	end;
	
	#	Parameters for make_and_present_block
	#	1. Value: seperate_attention: 1 = only a color is a target
	#											 2 = only a form is a target
	#											 3 = a color and a form is a target
	#	2. Value: index of color target. Use -1 if no color targets will be presentet
	#	3. Value: color array to be used
	#	4. Value: index of form target in form_array. Use -1 if no form targets will be presentet
	#	5. Value: number of targets in returned trial
	#	6. Value: number of non targets in returned trial
	#	7. Value: bool to determin if feedback will be given. true = feedback
	#	8. Value: condition_id for event_code
	#	9. Value: trial_id for event_code
	
	sub make_and_present_block (int seperate_attention, int color_target_index, array<int,1> color_indexes,
											int form_target_index, int number_of_targets, int number_of_non_targets,  
											bool show_feedback, string run_id, string block_id)
	begin
		array<int> block_presentet[][] = make_block(seperate_attention,color_target_index, array_color_indexes,
											form_target_index, number_of_targets, number_of_non_targets);
		present_block(seperate_attention, color_target_index, array_color_indexes,
											 form_target_index, block_presentet, show_feedback, run_id, block_id)
	end;
	

##########################Test Condition########################################
	set_response_mode(1);
	set_logfile_name();
	present_information(array_information[language][1], 25);
   present_information(array_information[language][2], 30);

	make_and_present_block(1, 1, array_color_indexes, -1, 4, 6, true, "test", "1");
	make_and_present_block(3, 2, array_color_indexes, 1, 4, 6, true, "test", "2");
	
	if configuration == 1
	then
		##########################Condition 1########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 7, 19, false, "selective", "1");
			make_and_present_block(1, 3, array_color_indexes, -1, 5, 21, false, "selective", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 6, 20, false, "selective", "3");
			make_and_present_block(2, -1, array_color_indexes, 3, 8, 18, false, "selective", "4");
			
		##########################Condition 2########################################

			pause_minutes(2);
			present_information(array_information[language][4], 30);
			make_and_present_block(3, 5, array_color_indexes, 4, 8, 18, false, "divided", "1");
			make_and_present_block(3, 6, array_color_indexes, 5, 5, 21, false, "divided", "2");
			make_and_present_block(3, 1, array_color_indexes, 6, 7, 19, false, "divided", "3");
			make_and_present_block(3, 2, array_color_indexes, 1, 6, 20, false, "divided", "4");
			
		##########################Condition 3########################################

			pause_minutes(2);
			present_information(array_information[language][5], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 7, 19, false, "switching", "1");
			make_and_present_block(3, 3, array_color_indexes, 3, 8, 18, false, "switching", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 5, 21, false, "switching", "3");
			make_and_present_block(3, 5, array_color_indexes, 4, 6, 20, false, "switching", "4");
			
			make_and_present_block(2, -1, array_color_indexes, 5, 6, 20, false, "switching", "5");
			make_and_present_block(3, 6, array_color_indexes, 6, 7, 19, false, "switching", "6");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "switching", "7");
			make_and_present_block(3, 2, array_color_indexes, 1, 8, 18, false, "switching", "8");
			present_information(array_information[language][6], 30);
			
	elseif configuration == 2
	then
		##########################Condition 1########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(3, 3, array_color_indexes, 2, 8, 18, false, "divided", "1");
			make_and_present_block(3, 4, array_color_indexes, 3, 5, 21, false, "divided", "2");
			make_and_present_block(3, 5, array_color_indexes, 4, 7, 19, false, "divided", "3");
			make_and_present_block(3, 6, array_color_indexes, 5, 6, 20, false, "divided", "4");
			
		##########################Condition 2########################################

			pause_minutes(2);
			present_information(array_information[language][4], 30);
			make_and_present_block(2, -1, array_color_indexes, 6, 7, 19, false, "selective", "1");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "selective", "2");
			make_and_present_block(1, 2, array_color_indexes, -1, 6, 20, false, "selective", "3");
			make_and_present_block(2, -1, array_color_indexes, 1, 8, 18, false, "selective", "4");
			
		##########################Condition 3########################################

			pause_minutes(2);
			present_information(array_information[language][5], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 7, 19, false, "switching", "1");
			make_and_present_block(3, 3, array_color_indexes, 3, 8, 18, false, "switching", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 5, 21, false, "switching", "3");
			make_and_present_block(3, 5, array_color_indexes, 4, 6, 20, false, "switching", "4");
			
			make_and_present_block(2, -1, array_color_indexes, 5, 6, 20, false, "switching", "5");
			make_and_present_block(3, 6, array_color_indexes, 6, 7, 19, false, "switching", "6");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "switching", "7");
			make_and_present_block(3, 2, array_color_indexes, 1, 8, 18, false, "switching", "8");
			present_information(array_information[language][6], 30);
			
	elseif configuration == 3
	then
		##########################Condition 1########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 7, 19, false, "switching", "1");
			make_and_present_block(3, 3, array_color_indexes, 3, 8, 18, false, "switching", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 5, 21, false, "switching", "3");
			make_and_present_block(3, 5, array_color_indexes, 4, 6, 20, false, "switching", "4");
			
			make_and_present_block(2, -1, array_color_indexes, 5, 6, 20, false, "switching", "5");
			make_and_present_block(3, 6, array_color_indexes, 6, 7, 19, false, "switching", "6");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "switching", "7");
			make_and_present_block(3, 2, array_color_indexes, 1, 8, 18, false, "switching", "8");
			
		##########################Condition 2########################################

			pause_minutes(2);
			present_information(array_information[language][4], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 8, 18, false, "selective", "1");
			make_and_present_block(1, 3, array_color_indexes, -1, 5, 21, false, "selective", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 7, 19, false, "selective", "3");
			make_and_present_block(2, -1, array_color_indexes, 3, 6, 20, false, "selective", "4");
			
		##########################Condition 3########################################

			pause_minutes(2);
			present_information(array_information[language][5], 30);
			make_and_present_block(3, 5, array_color_indexes, 4, 7, 19, false, "divided", "1");
			make_and_present_block(3, 6, array_color_indexes, 5, 5, 21, false, "divided", "2");
			make_and_present_block(3, 1, array_color_indexes, 6, 6, 20, false, "divided", "3");
			make_and_present_block(3, 2, array_color_indexes, 1, 8, 18, false, "divided", "4");
			present_information(array_information[language][6], 30);
			
	elseif configuration == 4
	then
		##########################Condition 1########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 7, 19, false, "switching", "1");
			make_and_present_block(3, 3, array_color_indexes, 3, 8, 18, false, "switching", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 5, 21, false, "switching", "3");
			make_and_present_block(3, 5, array_color_indexes, 4, 6, 20, false, "switching", "4");
			
			make_and_present_block(2, -1, array_color_indexes, 5, 6, 20, false, "switching", "5");
			make_and_present_block(3, 6, array_color_indexes, 6, 7, 19, false, "switching", "6");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "switching", "7");
			make_and_present_block(3, 2, array_color_indexes, 1, 8, 18, false, "switching", "8");
			
		##########################Condition 2########################################

			pause_minutes(2);
			present_information(array_information[language][4], 30);
			make_and_present_block(3, 3, array_color_indexes, 2, 7, 19, false, "divided", "1");
			make_and_present_block(3, 4, array_color_indexes, 3, 5, 21, false, "divided", "2");
			make_and_present_block(3, 5, array_color_indexes, 4, 6, 20, false, "divided", "3");
			make_and_present_block(3, 6, array_color_indexes, 5, 8, 18, false, "divided", "4");
			
		##########################Condition 3########################################

			pause_minutes(2);
			present_information(array_information[language][5], 30);
			make_and_present_block(2, -1, array_color_indexes, 6, 8, 18, false, "selective", "1");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "selective", "2");
			make_and_present_block(1, 2, array_color_indexes, -1, 7, 19, false, "selective", "3");
			make_and_present_block(2, -1, array_color_indexes, 1, 6, 20, false, "selective", "4");
			present_information(array_information[language][6], 30);
			
	elseif configuration == 5
	then
		##########################Condition 1########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 8, 18, false, "selective", "1");
			make_and_present_block(1, 3, array_color_indexes, -1, 5, 21, false, "selective", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 7, 19, false, "selective", "3");
			make_and_present_block(2, -1, array_color_indexes, 3, 6, 20, false, "selective", "4");
			
		##########################Condition 2########################################

			pause_minutes(2);
			present_information(array_information[language][4], 30);
			make_and_present_block(2, -1, array_color_indexes, 4, 7, 19, false, "switching", "1");
			make_and_present_block(3, 5, array_color_indexes, 5, 8, 18, false, "switching", "2");
			make_and_present_block(1, 6, array_color_indexes, -1, 5, 21, false, "switching", "3");
			make_and_present_block(3, 1, array_color_indexes, 6, 6, 20, false, "switching", "4");
			
			make_and_present_block(2, -1, array_color_indexes, 1, 6, 20, false, "switching", "5");
			make_and_present_block(3, 2, array_color_indexes, 2, 7, 19, false, "switching", "6");
			make_and_present_block(1, 3, array_color_indexes, -1, 5, 21, false, "switching", "7");
			make_and_present_block(3, 4, array_color_indexes, 3, 8, 18, false, "switching", "8");
			
		##########################Condition 3########################################

			pause_minutes(2);
			present_information(array_information[language][5], 30);
			make_and_present_block(3, 5, array_color_indexes, 4, 7, 19, false, "divided", "1");
			make_and_present_block(3, 6, array_color_indexes, 5, 5, 21, false, "divided", "2");
			make_and_present_block(3, 1, array_color_indexes, 6, 6, 20, false, "divided", "3");
			make_and_present_block(3, 2, array_color_indexes, 1, 8, 18, false, "divided", "4");
			present_information(array_information[language][6], 30);
			
	elseif configuration == 6
	then
		##########################Condition 1########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(3, 3, array_color_indexes, 2, 7, 19, false, "divided", "1");
			make_and_present_block(3, 4, array_color_indexes, 3, 5, 21, false, "divided", "2");
			make_and_present_block(3, 5, array_color_indexes, 4, 6, 20, false, "divided", "3");
			make_and_present_block(3, 6, array_color_indexes, 5, 8, 18, false, "divided", "4");
			
		##########################Condition 2########################################

			pause_minutes(2);
			present_information(array_information[language][4], 30);
			make_and_present_block(2, -1, array_color_indexes, 6, 7, 19, false, "switching", "1");
			make_and_present_block(3, 1, array_color_indexes, 1, 8, 18, false, "switching", "2");
			make_and_present_block(1, 2, array_color_indexes, -1, 5, 21, false, "switching", "3");
			make_and_present_block(3, 3, array_color_indexes, 2, 6, 20, false, "switching", "4");
			
			make_and_present_block(2, -1, array_color_indexes, 3, 6, 20, false, "switching", "5");
			make_and_present_block(3, 4, array_color_indexes, 4, 7, 19, false, "switching", "6");
			make_and_present_block(1, 5, array_color_indexes, -1, 5, 21, false, "switching", "7");
			make_and_present_block(3, 6, array_color_indexes, 5, 8, 18, false, "switching", "8");
			
		##########################Condition 3########################################

			pause_minutes(2);
			present_information(array_information[language][5], 30);
			make_and_present_block(2, -1, array_color_indexes, 6, 8, 18, false, "selective", "1");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "selective", "2");
			make_and_present_block(1, 2, array_color_indexes, -1, 7, 19, false, "selective", "3");
			make_and_present_block(2, -1, array_color_indexes, 1, 6, 20, false, "selective", "4");
			present_information(array_information[language][6], 30);
	
	elseif configuration == 7
	then
		##########################Only Selective########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 7, 19, false, "selective", "1");
			make_and_present_block(1, 3, array_color_indexes, -1, 5, 21, false, "selective", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 6, 20, false, "selective", "3");
			make_and_present_block(2, -1, array_color_indexes, 3, 8, 18, false, "selective", "4");
			present_information(array_information[language][6], 30);
			
	elseif configuration == 8
	then
		##########################Only Divided########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(3, 3, array_color_indexes, 2, 8, 18, false, "divided", "1");
			make_and_present_block(3, 4, array_color_indexes, 3, 5, 21, false, "divided", "2");
			make_and_present_block(3, 5, array_color_indexes, 4, 7, 19, false, "divided", "3");
			make_and_present_block(3, 6, array_color_indexes, 5, 6, 20, false, "divided", "4");
			present_information(array_information[language][6], 30);
			
	elseif configuration == 9
	then
		##########################Only Switching########################################

			pause_seconds(30);
			present_information(array_information[language][3], 30);
			make_and_present_block(2, -1, array_color_indexes, 2, 7, 19, false, "switching", "1");
			make_and_present_block(3, 3, array_color_indexes, 3, 8, 18, false, "switching", "2");
			make_and_present_block(1, 4, array_color_indexes, -1, 5, 21, false, "switching", "3");
			make_and_present_block(3, 5, array_color_indexes, 4, 6, 20, false, "switching", "4");
			
			make_and_present_block(2, -1, array_color_indexes, 5, 6, 20, false, "switching", "5");
			make_and_present_block(3, 6, array_color_indexes, 6, 7, 19, false, "switching", "6");
			make_and_present_block(1, 1, array_color_indexes, -1, 5, 21, false, "switching", "7");
			make_and_present_block(3, 2, array_color_indexes, 1, 8, 18, false, "switching", "8");
			present_information(array_information[language][6], 30);		
	end;		
			
	tracker.stop_data(dt_position);
	tracker.set_recording(false);
	tracker.stop_tracking();
	
	tracker2.save_data("C:\\Algpsy\\Swad_kids\\SwaD_kids_et_" + logfile.subject() + ".idf", "description", logfile.subject(), 1);
	tracker.clear_buffer(dt_position);
	tracker2.disconnect();
